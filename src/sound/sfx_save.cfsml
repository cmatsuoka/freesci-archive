/***************************************************************************
 sfx_save.cfsml Copyright (C) 1999 Christoph Reichenbach, TU Darmstadt


 This program may be modified and copied freely according to the terms of
 the GNU general public license (GPL), as long as the above copyright
 notice and the licensing information contained herein are preserved.

 Please refer to www.gnu.org for licensing details.

 This work is provided AS IS, without warranty of any kind, expressed or
 implied, including but not limited to the warranties of merchantibility,
 noninfringement, and fitness for a specific purpose. The author will not
 be held liable for any damage caused by this work or derivatives of it.

 By using this source code, you agree to the licensing terms as stated
 above.


 Please contact the maintainer for bug reports or inquiries.

 Current Maintainer:

    Christoph Reichenbach (CJR) [jameson@linuxgames.com]

***************************************************************************/
/* CFSML file providing persistance to the sound system
** Note that this is only useful if the default sound library implementation
** is in use.
*/

#include <stdio.h>
#include <sound.h>
#include <soundserver.h>
#include <sci_memory.h>

#ifdef _WIN32
#include <direct.h>
#define chdir _chdir
#define getcwd _getcwd
#endif


#ifndef O_BINARY
#define O_BINARY 0
#endif  /* !O_BINARY */

#define SOUND_SAVEGAME_VERSION 1;

typedef struct {

	int sound_version;

	int songs_nr; /* Number of songs */
	song_t *songs; /* All songs in order */

	int active_song;

	int master_volume; /* duh.. */
	int soundcue; /* Cumulative sound cue */
	long usecs_to_sleep; /* Microseconds until the next tick is due */
	long ticks_to_wait; /* Ticks until the next sound command has to be interpreted */
	long ticks_to_fade; /* Ticks until a fade-out is complete */

} sound_lib_file_t;



%CFSML

TYPE word "word" LIKE int
TYPE long "long" LIKE int
TYPE short "short" LIKE int

RECORD song_t "song_t" {

	int flags[STATIC MIDI_CHANNELS];
	int instruments[STATIC MIDI_CHANNELS];
	int velocity[STATIC MIDI_CHANNELS];
	int pressure[STATIC MIDI_CHANNELS];
	int pitch[STATIC MIDI_CHANNELS];
	int channel_map[STATIC MIDI_CHANNELS];

	int size;
	int pos;
	int loopmark;
	long fading;

	short reverb;
	long maxfade;
	int resetflag;
	int polyphony[STATIC MIDI_CHANNELS];

	int file_nr;
	int priority;
	int loops;
	int status;

	word handle;
}

RECORD sound_lib_file_t "sound_lib_file_t" {

	int sound_version;

	song_t songs[DYNAMIC songs_nr];

	int active_song;

	int soundcue;
	long usecs_to_sleep;
	long ticks_to_wait;
	long ticks_to_fade;

}

%END CFSML


/* Sound state saving reference implementation */
int
soundsrv_save_state(FILE *debugstream, char *dir, sound_server_state_t *sss)
{
	sound_lib_file_t write_rec;
	song_t *seeker;
	int songctr = 0;
	int curr_song_nr = -1;
	FILE *fh;

	if (dir && chdir(dir)) {
		char *cwd;

		cwd = getcwd(NULL, 0);
		fprintf(debugstream, "Failed to enter '%s', cwd is '%s'\n", dir, cwd);
		free(cwd);
		return 1;
	}

	write_rec.sound_version = SOUND_SAVEGAME_VERSION;

	write_rec.soundcue = sss->sound_cue;
	write_rec.usecs_to_sleep = sss->usecs_to_sleep;
	write_rec.ticks_to_wait = sss->ticks_to_wait;
	write_rec.ticks_to_fade = 0;
	write_rec.master_volume = sss->master_volume;

	/* Determine number of songs */
	seeker = *sss->songlib;
	while (seeker) {

		if (seeker == sss->current_song)
			curr_song_nr = songctr;

		++songctr;
		seeker = seeker->next;
	}

	write_rec.songs_nr = songctr;
	write_rec.active_song = curr_song_nr;

	write_rec.songs = sci_malloc(sizeof(song_t) * songctr);

	/* Now memcpy those songs into a row and write their song data to a file */
	songctr = -1;
	seeker = *sss->songlib;
	while (seeker) {
		char filename[10];
		FILE *fh;
		++songctr;

		memcpy(&(write_rec.songs[songctr]), seeker, sizeof(song_t));
		write_rec.songs[songctr].file_nr = songctr;

		/* Now write to an external file */
		sprintf(filename, "song.%d", songctr);
		fh = fopen(filename, "w" FO_BINARY);

		if (!fh) {
			fprintf(debugstream, "Error creating file: %s while creating '%s/%s'\n",
			      strerror(errno), dir, filename);
			free(write_rec.songs);
			if (dir)
				chdir ("..");
			return 1;
		}

		if (fwrite(seeker->data, sizeof(byte), seeker->size, fh) < seeker->size) {
			fprintf(debugstream, "Write error: Failed to write to '%s/%s'\n", dir, filename);
			free(write_rec.songs);
			if (dir)
				chdir ("..");
			return 1;
		}
		fclose(fh);

		seeker = seeker->next;
	}

	fh = fopen("sound", "w" FO_TEXT);

	%CFSMLWRITE sound_lib_file_t &write_rec INTO fh;

	fclose(fh);
	fprintf(stderr,"Finished all writing.\n");

	free(write_rec.songs);

	if (dir)
		chdir ("..");
	return 0;
}

static void
recover_version0(sound_lib_file_t *rec)
{
	int i;

	for (i = 0; i < rec->songs_nr; i++) {
		int j;
		song_t *song = rec->songs + i;

		song->reverb = 0;
		song->maxfade = 16;
		song->resetflag = 0;

		for (j = 0; j < MIDI_CHANNELS; j++)
			song->polyphony[j] = 1;
	}
}

/* Sound state restore complement for the saving reference implementation */
int
soundsrv_restore_state(FILE *debugstream, char *dir, sound_server_state_t *sss)
{
	FILE *fh;
	sound_lib_file_t read_rec;
	song_t *seeker, *next = NULL;
	int error;
	int i;
	if (dir && chdir(dir)) {
		fprintf(debugstream, "Failed to enter '%s'\n", dir);
		return 1;
	}

	fh = fopen("sound", "r" FO_TEXT);

	if (!fh) {
		fprintf(debugstream, "'%s/sound' not found!\n", dir);
		if (dir)
	    chdir ("..");
		return 1;
	}

	read_rec.songs = NULL;

	/* Backwards capability crap */
	read_rec.sound_version = 0;
	read_rec.master_volume = sss->master_volume;
	%CFSMLREAD-ATOMIC sound_lib_file_t &read_rec FROM fh ERRVAR error;

	if (read_rec.sound_version == 0)
		recover_version0(&read_rec);

	if (error) {
		if(read_rec.songs)
			free(read_rec.songs);

		if (dir)
			chdir ("..");
		fprintf(debugstream, "Failed to parse '%s/sound'\n", dir);
		return 1;
	}

	for (i = 0; i < read_rec.songs_nr; i++) {
		int size = read_rec.songs[i].size;
		char filename[10];
		int fd;

		sprintf(filename, "song.%d", read_rec.songs[i].file_nr);
		fh = fopen(filename, "r" FO_BINARY);

		if (!fh) {
			if (dir)
				chdir ("..");
			fprintf(debugstream, "Opening %s/%s failed: %s\n", dir, filename, strerror(errno));
			if(read_rec.songs)
				free(read_rec.songs);
			return 1;
		}

		read_rec.songs[i].data = (byte *) sci_malloc(size);
		if (fread(read_rec.songs[i].data, sizeof(byte), size, fh) < size) {
			int j;
			for (j = 0; j < i; j++)
				free(read_rec.songs[i].data);
			if (dir)
				chdir ("..");
			fprintf(debugstream, "Reading %d bytes from %s/%s failed\n", size, dir, filename);
			return 1;
		}

		fclose(fh);
	}


	song_lib_free(sss->songlib); /* Everything is well, so free all  songs */

	sss->current_song = NULL;

	for (i = 0; i < read_rec.songs_nr; i++) {

		next = sci_malloc(sizeof(song_t));	
		memcpy(next, &(read_rec.songs[i]), sizeof(song_t));
		next->next = NULL;
		if (i > 0)
			seeker->next = next;

		seeker = next;

		if (i == 0)
			*sss->songlib = seeker;

		if (i == read_rec.active_song)
			sss->current_song = seeker;
	}

	sss->sound_cue = read_rec.soundcue;
	sss->usecs_to_sleep = read_rec.usecs_to_sleep;
	sss->ticks_to_wait = read_rec.ticks_to_wait;
	/* sss->ticks_to_fade = read_rec.ticks_to_fade; */
	sss->master_volume = read_rec.master_volume;

	if (read_rec.songs_nr)
		free(read_rec.songs);

	if (dir)
	  chdir ("..");

	return 0;
}
